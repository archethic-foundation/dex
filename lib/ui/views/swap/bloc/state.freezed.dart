// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SwapFormState {
  int get step => throw _privateConstructorUsedError;
  String get stepError => throw _privateConstructorUsedError;
  DexToken? get tokenToSwap => throw _privateConstructorUsedError;
  double get tokenToSwapBalance => throw _privateConstructorUsedError;
  double get tokenToSwapAmount => throw _privateConstructorUsedError;
  double get tokenToSwapAmountFiat => throw _privateConstructorUsedError;
  DexToken? get tokenSwapped => throw _privateConstructorUsedError;
  double get tokenSwappedBalance => throw _privateConstructorUsedError;
  double get tokenSwappedAmount => throw _privateConstructorUsedError;
  double get tokenSwappedAmountFiat => throw _privateConstructorUsedError;
  String get poolAddress => throw _privateConstructorUsedError;
  double get networkFees => throw _privateConstructorUsedError;
  double get networkFeesFiat => throw _privateConstructorUsedError;
  double get swapFees => throw _privateConstructorUsedError;
  double get swapFeesFiat => throw _privateConstructorUsedError;
  double get slippageTolerance => throw _privateConstructorUsedError;
  bool get expertMode => throw _privateConstructorUsedError;
  double get minimumReceived => throw _privateConstructorUsedError;
  double get priceImpact => throw _privateConstructorUsedError;
  double get estimatedReceived => throw _privateConstructorUsedError;
  bool? get controlInProgress => throw _privateConstructorUsedError;
  String get errorText => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SwapFormStateCopyWith<SwapFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapFormStateCopyWith<$Res> {
  factory $SwapFormStateCopyWith(
          SwapFormState value, $Res Function(SwapFormState) then) =
      _$SwapFormStateCopyWithImpl<$Res, SwapFormState>;
  @useResult
  $Res call(
      {int step,
      String stepError,
      DexToken? tokenToSwap,
      double tokenToSwapBalance,
      double tokenToSwapAmount,
      double tokenToSwapAmountFiat,
      DexToken? tokenSwapped,
      double tokenSwappedBalance,
      double tokenSwappedAmount,
      double tokenSwappedAmountFiat,
      String poolAddress,
      double networkFees,
      double networkFeesFiat,
      double swapFees,
      double swapFeesFiat,
      double slippageTolerance,
      bool expertMode,
      double minimumReceived,
      double priceImpact,
      double estimatedReceived,
      bool? controlInProgress,
      String errorText});

  $DexTokenCopyWith<$Res>? get tokenToSwap;
  $DexTokenCopyWith<$Res>? get tokenSwapped;
}

/// @nodoc
class _$SwapFormStateCopyWithImpl<$Res, $Val extends SwapFormState>
    implements $SwapFormStateCopyWith<$Res> {
  _$SwapFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = null,
    Object? stepError = null,
    Object? tokenToSwap = freezed,
    Object? tokenToSwapBalance = null,
    Object? tokenToSwapAmount = null,
    Object? tokenToSwapAmountFiat = null,
    Object? tokenSwapped = freezed,
    Object? tokenSwappedBalance = null,
    Object? tokenSwappedAmount = null,
    Object? tokenSwappedAmountFiat = null,
    Object? poolAddress = null,
    Object? networkFees = null,
    Object? networkFeesFiat = null,
    Object? swapFees = null,
    Object? swapFeesFiat = null,
    Object? slippageTolerance = null,
    Object? expertMode = null,
    Object? minimumReceived = null,
    Object? priceImpact = null,
    Object? estimatedReceived = null,
    Object? controlInProgress = freezed,
    Object? errorText = null,
  }) {
    return _then(_value.copyWith(
      step: null == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as int,
      stepError: null == stepError
          ? _value.stepError
          : stepError // ignore: cast_nullable_to_non_nullable
              as String,
      tokenToSwap: freezed == tokenToSwap
          ? _value.tokenToSwap
          : tokenToSwap // ignore: cast_nullable_to_non_nullable
              as DexToken?,
      tokenToSwapBalance: null == tokenToSwapBalance
          ? _value.tokenToSwapBalance
          : tokenToSwapBalance // ignore: cast_nullable_to_non_nullable
              as double,
      tokenToSwapAmount: null == tokenToSwapAmount
          ? _value.tokenToSwapAmount
          : tokenToSwapAmount // ignore: cast_nullable_to_non_nullable
              as double,
      tokenToSwapAmountFiat: null == tokenToSwapAmountFiat
          ? _value.tokenToSwapAmountFiat
          : tokenToSwapAmountFiat // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwapped: freezed == tokenSwapped
          ? _value.tokenSwapped
          : tokenSwapped // ignore: cast_nullable_to_non_nullable
              as DexToken?,
      tokenSwappedBalance: null == tokenSwappedBalance
          ? _value.tokenSwappedBalance
          : tokenSwappedBalance // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwappedAmount: null == tokenSwappedAmount
          ? _value.tokenSwappedAmount
          : tokenSwappedAmount // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwappedAmountFiat: null == tokenSwappedAmountFiat
          ? _value.tokenSwappedAmountFiat
          : tokenSwappedAmountFiat // ignore: cast_nullable_to_non_nullable
              as double,
      poolAddress: null == poolAddress
          ? _value.poolAddress
          : poolAddress // ignore: cast_nullable_to_non_nullable
              as String,
      networkFees: null == networkFees
          ? _value.networkFees
          : networkFees // ignore: cast_nullable_to_non_nullable
              as double,
      networkFeesFiat: null == networkFeesFiat
          ? _value.networkFeesFiat
          : networkFeesFiat // ignore: cast_nullable_to_non_nullable
              as double,
      swapFees: null == swapFees
          ? _value.swapFees
          : swapFees // ignore: cast_nullable_to_non_nullable
              as double,
      swapFeesFiat: null == swapFeesFiat
          ? _value.swapFeesFiat
          : swapFeesFiat // ignore: cast_nullable_to_non_nullable
              as double,
      slippageTolerance: null == slippageTolerance
          ? _value.slippageTolerance
          : slippageTolerance // ignore: cast_nullable_to_non_nullable
              as double,
      expertMode: null == expertMode
          ? _value.expertMode
          : expertMode // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumReceived: null == minimumReceived
          ? _value.minimumReceived
          : minimumReceived // ignore: cast_nullable_to_non_nullable
              as double,
      priceImpact: null == priceImpact
          ? _value.priceImpact
          : priceImpact // ignore: cast_nullable_to_non_nullable
              as double,
      estimatedReceived: null == estimatedReceived
          ? _value.estimatedReceived
          : estimatedReceived // ignore: cast_nullable_to_non_nullable
              as double,
      controlInProgress: freezed == controlInProgress
          ? _value.controlInProgress
          : controlInProgress // ignore: cast_nullable_to_non_nullable
              as bool?,
      errorText: null == errorText
          ? _value.errorText
          : errorText // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DexTokenCopyWith<$Res>? get tokenToSwap {
    if (_value.tokenToSwap == null) {
      return null;
    }

    return $DexTokenCopyWith<$Res>(_value.tokenToSwap!, (value) {
      return _then(_value.copyWith(tokenToSwap: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DexTokenCopyWith<$Res>? get tokenSwapped {
    if (_value.tokenSwapped == null) {
      return null;
    }

    return $DexTokenCopyWith<$Res>(_value.tokenSwapped!, (value) {
      return _then(_value.copyWith(tokenSwapped: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SwapFormStateImplCopyWith<$Res>
    implements $SwapFormStateCopyWith<$Res> {
  factory _$$SwapFormStateImplCopyWith(
          _$SwapFormStateImpl value, $Res Function(_$SwapFormStateImpl) then) =
      __$$SwapFormStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int step,
      String stepError,
      DexToken? tokenToSwap,
      double tokenToSwapBalance,
      double tokenToSwapAmount,
      double tokenToSwapAmountFiat,
      DexToken? tokenSwapped,
      double tokenSwappedBalance,
      double tokenSwappedAmount,
      double tokenSwappedAmountFiat,
      String poolAddress,
      double networkFees,
      double networkFeesFiat,
      double swapFees,
      double swapFeesFiat,
      double slippageTolerance,
      bool expertMode,
      double minimumReceived,
      double priceImpact,
      double estimatedReceived,
      bool? controlInProgress,
      String errorText});

  @override
  $DexTokenCopyWith<$Res>? get tokenToSwap;
  @override
  $DexTokenCopyWith<$Res>? get tokenSwapped;
}

/// @nodoc
class __$$SwapFormStateImplCopyWithImpl<$Res>
    extends _$SwapFormStateCopyWithImpl<$Res, _$SwapFormStateImpl>
    implements _$$SwapFormStateImplCopyWith<$Res> {
  __$$SwapFormStateImplCopyWithImpl(
      _$SwapFormStateImpl _value, $Res Function(_$SwapFormStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = null,
    Object? stepError = null,
    Object? tokenToSwap = freezed,
    Object? tokenToSwapBalance = null,
    Object? tokenToSwapAmount = null,
    Object? tokenToSwapAmountFiat = null,
    Object? tokenSwapped = freezed,
    Object? tokenSwappedBalance = null,
    Object? tokenSwappedAmount = null,
    Object? tokenSwappedAmountFiat = null,
    Object? poolAddress = null,
    Object? networkFees = null,
    Object? networkFeesFiat = null,
    Object? swapFees = null,
    Object? swapFeesFiat = null,
    Object? slippageTolerance = null,
    Object? expertMode = null,
    Object? minimumReceived = null,
    Object? priceImpact = null,
    Object? estimatedReceived = null,
    Object? controlInProgress = freezed,
    Object? errorText = null,
  }) {
    return _then(_$SwapFormStateImpl(
      step: null == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as int,
      stepError: null == stepError
          ? _value.stepError
          : stepError // ignore: cast_nullable_to_non_nullable
              as String,
      tokenToSwap: freezed == tokenToSwap
          ? _value.tokenToSwap
          : tokenToSwap // ignore: cast_nullable_to_non_nullable
              as DexToken?,
      tokenToSwapBalance: null == tokenToSwapBalance
          ? _value.tokenToSwapBalance
          : tokenToSwapBalance // ignore: cast_nullable_to_non_nullable
              as double,
      tokenToSwapAmount: null == tokenToSwapAmount
          ? _value.tokenToSwapAmount
          : tokenToSwapAmount // ignore: cast_nullable_to_non_nullable
              as double,
      tokenToSwapAmountFiat: null == tokenToSwapAmountFiat
          ? _value.tokenToSwapAmountFiat
          : tokenToSwapAmountFiat // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwapped: freezed == tokenSwapped
          ? _value.tokenSwapped
          : tokenSwapped // ignore: cast_nullable_to_non_nullable
              as DexToken?,
      tokenSwappedBalance: null == tokenSwappedBalance
          ? _value.tokenSwappedBalance
          : tokenSwappedBalance // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwappedAmount: null == tokenSwappedAmount
          ? _value.tokenSwappedAmount
          : tokenSwappedAmount // ignore: cast_nullable_to_non_nullable
              as double,
      tokenSwappedAmountFiat: null == tokenSwappedAmountFiat
          ? _value.tokenSwappedAmountFiat
          : tokenSwappedAmountFiat // ignore: cast_nullable_to_non_nullable
              as double,
      poolAddress: null == poolAddress
          ? _value.poolAddress
          : poolAddress // ignore: cast_nullable_to_non_nullable
              as String,
      networkFees: null == networkFees
          ? _value.networkFees
          : networkFees // ignore: cast_nullable_to_non_nullable
              as double,
      networkFeesFiat: null == networkFeesFiat
          ? _value.networkFeesFiat
          : networkFeesFiat // ignore: cast_nullable_to_non_nullable
              as double,
      swapFees: null == swapFees
          ? _value.swapFees
          : swapFees // ignore: cast_nullable_to_non_nullable
              as double,
      swapFeesFiat: null == swapFeesFiat
          ? _value.swapFeesFiat
          : swapFeesFiat // ignore: cast_nullable_to_non_nullable
              as double,
      slippageTolerance: null == slippageTolerance
          ? _value.slippageTolerance
          : slippageTolerance // ignore: cast_nullable_to_non_nullable
              as double,
      expertMode: null == expertMode
          ? _value.expertMode
          : expertMode // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumReceived: null == minimumReceived
          ? _value.minimumReceived
          : minimumReceived // ignore: cast_nullable_to_non_nullable
              as double,
      priceImpact: null == priceImpact
          ? _value.priceImpact
          : priceImpact // ignore: cast_nullable_to_non_nullable
              as double,
      estimatedReceived: null == estimatedReceived
          ? _value.estimatedReceived
          : estimatedReceived // ignore: cast_nullable_to_non_nullable
              as double,
      controlInProgress: freezed == controlInProgress
          ? _value.controlInProgress
          : controlInProgress // ignore: cast_nullable_to_non_nullable
              as bool?,
      errorText: null == errorText
          ? _value.errorText
          : errorText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SwapFormStateImpl extends _SwapFormState {
  const _$SwapFormStateImpl(
      {this.step = 0,
      this.stepError = '',
      this.tokenToSwap,
      this.tokenToSwapBalance = 0,
      this.tokenToSwapAmount = 0,
      this.tokenToSwapAmountFiat = 0,
      this.tokenSwapped,
      this.tokenSwappedBalance = 0,
      this.tokenSwappedAmount = 0,
      this.tokenSwappedAmountFiat = 0,
      this.poolAddress =
          '0000BD123724608AFB6B52B193585A9EB8DA9680315DC2C55621AFAE8C65796CF3C8',
      this.networkFees = 0.0,
      this.networkFeesFiat = 0.0,
      this.swapFees = 0.0,
      this.swapFeesFiat = 0.0,
      this.slippageTolerance = 0.5,
      this.expertMode = false,
      this.minimumReceived = 0.0,
      this.priceImpact = 0.0,
      this.estimatedReceived = 0.0,
      this.controlInProgress = false,
      this.errorText = ''})
      : super._();

  @override
  @JsonKey()
  final int step;
  @override
  @JsonKey()
  final String stepError;
  @override
  final DexToken? tokenToSwap;
  @override
  @JsonKey()
  final double tokenToSwapBalance;
  @override
  @JsonKey()
  final double tokenToSwapAmount;
  @override
  @JsonKey()
  final double tokenToSwapAmountFiat;
  @override
  final DexToken? tokenSwapped;
  @override
  @JsonKey()
  final double tokenSwappedBalance;
  @override
  @JsonKey()
  final double tokenSwappedAmount;
  @override
  @JsonKey()
  final double tokenSwappedAmountFiat;
  @override
  @JsonKey()
  final String poolAddress;
  @override
  @JsonKey()
  final double networkFees;
  @override
  @JsonKey()
  final double networkFeesFiat;
  @override
  @JsonKey()
  final double swapFees;
  @override
  @JsonKey()
  final double swapFeesFiat;
  @override
  @JsonKey()
  final double slippageTolerance;
  @override
  @JsonKey()
  final bool expertMode;
  @override
  @JsonKey()
  final double minimumReceived;
  @override
  @JsonKey()
  final double priceImpact;
  @override
  @JsonKey()
  final double estimatedReceived;
  @override
  @JsonKey()
  final bool? controlInProgress;
  @override
  @JsonKey()
  final String errorText;

  @override
  String toString() {
    return 'SwapFormState(step: $step, stepError: $stepError, tokenToSwap: $tokenToSwap, tokenToSwapBalance: $tokenToSwapBalance, tokenToSwapAmount: $tokenToSwapAmount, tokenToSwapAmountFiat: $tokenToSwapAmountFiat, tokenSwapped: $tokenSwapped, tokenSwappedBalance: $tokenSwappedBalance, tokenSwappedAmount: $tokenSwappedAmount, tokenSwappedAmountFiat: $tokenSwappedAmountFiat, poolAddress: $poolAddress, networkFees: $networkFees, networkFeesFiat: $networkFeesFiat, swapFees: $swapFees, swapFeesFiat: $swapFeesFiat, slippageTolerance: $slippageTolerance, expertMode: $expertMode, minimumReceived: $minimumReceived, priceImpact: $priceImpact, estimatedReceived: $estimatedReceived, controlInProgress: $controlInProgress, errorText: $errorText)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapFormStateImpl &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.stepError, stepError) ||
                other.stepError == stepError) &&
            (identical(other.tokenToSwap, tokenToSwap) ||
                other.tokenToSwap == tokenToSwap) &&
            (identical(other.tokenToSwapBalance, tokenToSwapBalance) ||
                other.tokenToSwapBalance == tokenToSwapBalance) &&
            (identical(other.tokenToSwapAmount, tokenToSwapAmount) ||
                other.tokenToSwapAmount == tokenToSwapAmount) &&
            (identical(other.tokenToSwapAmountFiat, tokenToSwapAmountFiat) ||
                other.tokenToSwapAmountFiat == tokenToSwapAmountFiat) &&
            (identical(other.tokenSwapped, tokenSwapped) ||
                other.tokenSwapped == tokenSwapped) &&
            (identical(other.tokenSwappedBalance, tokenSwappedBalance) ||
                other.tokenSwappedBalance == tokenSwappedBalance) &&
            (identical(other.tokenSwappedAmount, tokenSwappedAmount) ||
                other.tokenSwappedAmount == tokenSwappedAmount) &&
            (identical(other.tokenSwappedAmountFiat, tokenSwappedAmountFiat) ||
                other.tokenSwappedAmountFiat == tokenSwappedAmountFiat) &&
            (identical(other.poolAddress, poolAddress) ||
                other.poolAddress == poolAddress) &&
            (identical(other.networkFees, networkFees) ||
                other.networkFees == networkFees) &&
            (identical(other.networkFeesFiat, networkFeesFiat) ||
                other.networkFeesFiat == networkFeesFiat) &&
            (identical(other.swapFees, swapFees) ||
                other.swapFees == swapFees) &&
            (identical(other.swapFeesFiat, swapFeesFiat) ||
                other.swapFeesFiat == swapFeesFiat) &&
            (identical(other.slippageTolerance, slippageTolerance) ||
                other.slippageTolerance == slippageTolerance) &&
            (identical(other.expertMode, expertMode) ||
                other.expertMode == expertMode) &&
            (identical(other.minimumReceived, minimumReceived) ||
                other.minimumReceived == minimumReceived) &&
            (identical(other.priceImpact, priceImpact) ||
                other.priceImpact == priceImpact) &&
            (identical(other.estimatedReceived, estimatedReceived) ||
                other.estimatedReceived == estimatedReceived) &&
            (identical(other.controlInProgress, controlInProgress) ||
                other.controlInProgress == controlInProgress) &&
            (identical(other.errorText, errorText) ||
                other.errorText == errorText));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        step,
        stepError,
        tokenToSwap,
        tokenToSwapBalance,
        tokenToSwapAmount,
        tokenToSwapAmountFiat,
        tokenSwapped,
        tokenSwappedBalance,
        tokenSwappedAmount,
        tokenSwappedAmountFiat,
        poolAddress,
        networkFees,
        networkFeesFiat,
        swapFees,
        swapFeesFiat,
        slippageTolerance,
        expertMode,
        minimumReceived,
        priceImpact,
        estimatedReceived,
        controlInProgress,
        errorText
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapFormStateImplCopyWith<_$SwapFormStateImpl> get copyWith =>
      __$$SwapFormStateImplCopyWithImpl<_$SwapFormStateImpl>(this, _$identity);
}

abstract class _SwapFormState extends SwapFormState {
  const factory _SwapFormState(
      {final int step,
      final String stepError,
      final DexToken? tokenToSwap,
      final double tokenToSwapBalance,
      final double tokenToSwapAmount,
      final double tokenToSwapAmountFiat,
      final DexToken? tokenSwapped,
      final double tokenSwappedBalance,
      final double tokenSwappedAmount,
      final double tokenSwappedAmountFiat,
      final String poolAddress,
      final double networkFees,
      final double networkFeesFiat,
      final double swapFees,
      final double swapFeesFiat,
      final double slippageTolerance,
      final bool expertMode,
      final double minimumReceived,
      final double priceImpact,
      final double estimatedReceived,
      final bool? controlInProgress,
      final String errorText}) = _$SwapFormStateImpl;
  const _SwapFormState._() : super._();

  @override
  int get step;
  @override
  String get stepError;
  @override
  DexToken? get tokenToSwap;
  @override
  double get tokenToSwapBalance;
  @override
  double get tokenToSwapAmount;
  @override
  double get tokenToSwapAmountFiat;
  @override
  DexToken? get tokenSwapped;
  @override
  double get tokenSwappedBalance;
  @override
  double get tokenSwappedAmount;
  @override
  double get tokenSwappedAmountFiat;
  @override
  String get poolAddress;
  @override
  double get networkFees;
  @override
  double get networkFeesFiat;
  @override
  double get swapFees;
  @override
  double get swapFeesFiat;
  @override
  double get slippageTolerance;
  @override
  bool get expertMode;
  @override
  double get minimumReceived;
  @override
  double get priceImpact;
  @override
  double get estimatedReceived;
  @override
  bool? get controlInProgress;
  @override
  String get errorText;
  @override
  @JsonKey(ignore: true)
  _$$SwapFormStateImplCopyWith<_$SwapFormStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
